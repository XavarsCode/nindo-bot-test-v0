// handlers/buttonHandler.js - Version corrig√©e avec logger avanc√©
const { EmbedBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = require('discord.js');
const config = require('../config');
const logger = require('../utils/logger');

async function handle(interaction, bot) {
    const customId = interaction.customId;
    
    logger.discord('buttonInteraction', {
        user: interaction.user,
        guild: interaction.guild,
        customId: customId,
        channel: interaction.channel
    });

    try {
        // Whitelist buttons
        if (customId === 'wl_request') {
            await handleWLRequest(interaction, bot);
        } else if (customId === 'wl_ready') {
            await handleWLReady(interaction, bot);
        } else if (customId.startsWith('wl_accept_')) {
            await handleWLAccept(interaction, bot);
        } else if (customId.startsWith('wl_refuse_')) {
            await handleWLRefuse(interaction, bot);
        } else if (customId.startsWith('wl_notes_')) {
            await handleWLNotes(interaction, bot);
        }
        
        // Fiche RP buttons
        else if (customId.startsWith('fiche_accept_')) {
            await handleFicheAccept(interaction, bot);
        } else if (customId.startsWith('fiche_refuse_')) {
            await handleFicheRefuse(interaction, bot);
        } else if (customId.startsWith('fiche_edit_')) {
            await handleFicheEdit(interaction, bot);
        }
        
        else {
            logger.warn(`Bouton non g√©r√©: ${customId}`, { customId, userId: interaction.user.id });
        }
        
    } catch (error) {
        logger.error(`Erreur dans buttonHandler pour ${customId}`, error, { critical: true });
        
        // R√©ponse d'erreur s√©curis√©e
        const errorMessage = '‚ùå Une erreur est survenue lors du traitement de cette action.';
        try {
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ content: errorMessage, ephemeral: true });
            } else if (interaction.deferred) {
                await interaction.editReply({ content: errorMessage });
            } else {
                await interaction.followUp({ content: errorMessage, ephemeral: true });
            }
        } catch (replyError) {
            logger.error('Erreur lors de l\'envoi du message d\'erreur', replyError);
        }
    }
}

// ==================== WHITELIST HANDLERS ====================

async function handleWLRequest(interaction, bot) {
    await interaction.deferReply({ ephemeral: true });
    const user = interaction.user;
    
    logger.info(`Demande WL initi√©e par ${user.username} (${user.id})`);
    
    try {
        // V√©rifier si l'utilisateur a d√©j√† une demande en cours
        const existingWL = await new Promise((resolve, reject) => {
            bot.database.db.get(
                "SELECT * FROM whitelist WHERE user_id = ? AND status = 'pending'", 
                [user.id],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });

        if (existingWL) {
            logger.info(`Demande WL rejet√©e - d√©j√† en cours: ${existingWL.id}`, { userId: user.id, existingId: existingWL.id });
            
            const embed = new EmbedBuilder()
                .setTitle('‚ö†Ô∏è Demande existante')
                .setDescription(`Vous avez d√©j√† une demande de whitelist en cours: \`${existingWL.id}\``)
                .setColor(config.COLORS.WARNING);

            await interaction.editReply({ embeds: [embed] });
            return;
        }

        const dmChannel = await user.createDM();
        const filter = m => m.author.id === user.id;

        logger.debug('Canal DM cr√©√©, d√©but des questions WL', { userId: user.id });

        // Intro
        const introEmbed = new EmbedBuilder()
            .setTitle('üéôÔ∏è Demande de Whitelist')
            .setDescription(`Bonjour ${user.username} !\n\nJe vais vous poser quelques questions pour votre demande de whitelist.\n\n**‚è±Ô∏è Vous avez ${config.LIMITS.DM_TIMEOUT / 60000} minutes pour r√©pondre √† chaque question.**`)
            .setColor(config.COLORS.INFO);

        await dmChannel.send({ embeds: [introEmbed] });

        // Question 1: Disponibilit√©s
        logger.debug('Question 1/3: Disponibilit√©s', { userId: user.id });
        const availabilityEmbed = new EmbedBuilder()
            .setTitle('üìÖ Vos disponibilit√©s (1/3)')
            .setDescription('Veuillez indiquer vos disponibilit√©s pour l\'entretien whitelist.\n\n**Exemple:** "Lundi 20h, Mardi 18h, Mercredi apr√®s 19h"')
            .setColor(config.COLORS.INFO);

        await dmChannel.send({ embeds: [availabilityEmbed] });

        const availabilityCollected = await dmChannel.awaitMessages({ 
            filter, 
            max: 1, 
            time: config.LIMITS.DM_TIMEOUT 
        });

        if (!availabilityCollected.first()) {
            logger.warn('Timeout question disponibilit√©s', { userId: user.id });
            await dmChannel.send('‚ùå Temps √©coul√©. Veuillez refaire votre demande.');
            await interaction.editReply({ content: '‚ùå Demande annul√©e (timeout).' });
            return;
        }

        const availability = availabilityCollected.first().content;
        logger.debug('R√©ponse disponibilit√©s re√ßue', { userId: user.id, length: availability.length });

        // Question 2: Pseudo Roblox
        logger.debug('Question 2/3: Pseudo Roblox', { userId: user.id });
        const robloxEmbed = new EmbedBuilder()
            .setTitle('üéÆ Pseudo Roblox (2/3)')
            .setDescription('Quel est votre pseudo Roblox ?')
            .setColor(config.COLORS.INFO);

        await dmChannel.send({ embeds: [robloxEmbed] });

        const robloxCollected = await dmChannel.awaitMessages({ 
            filter, 
            max: 1, 
            time: config.LIMITS.DM_TIMEOUT 
        });

        if (!robloxCollected.first()) {
            logger.warn('Timeout question pseudo Roblox', { userId: user.id });
            await dmChannel.send('‚ùå Temps √©coul√©. Veuillez refaire votre demande.');
            await interaction.editReply({ content: '‚ùå Demande annul√©e (timeout).' });
            return;
        }

        const robloxPseudo = robloxCollected.first().content;
        logger.debug('R√©ponse pseudo Roblox re√ßue', { userId: user.id, pseudo: robloxPseudo });

        // Question 3: √Çge (optionnel)
        logger.debug('Question 3/3: √Çge (optionnel)', { userId: user.id });
        const ageEmbed = new EmbedBuilder()
            .setTitle('üéÇ √Çge - Optionnel (3/3)')
            .setDescription('Quel est votre √¢ge ? (Tapez "skip" pour passer cette question)')
            .setColor(config.COLORS.INFO);

        await dmChannel.send({ embeds: [ageEmbed] });

        const ageCollected = await dmChannel.awaitMessages({ 
            filter, 
            max: 1, 
            time: config.LIMITS.DM_TIMEOUT 
        });

        if (!ageCollected.first()) {
            logger.warn('Timeout question √¢ge', { userId: user.id });
            await dmChannel.send('‚ùå Temps √©coul√©. Veuillez refaire votre demande.');
            await interaction.editReply({ content: '‚ùå Demande annul√©e (timeout).' });
            return;
        }

        const ageInput = ageCollected.first().content;
        const age = (ageInput && ageInput.toLowerCase() !== 'skip') ? parseInt(ageInput) : null;
        
        logger.debug('R√©ponse √¢ge re√ßue', { userId: user.id, age: age });

        // Cr√©er la demande en base
        const appointmentTime = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();
        
        logger.debug('Cr√©ation demande WL en base', { userId: user.id });
        const wlId = await bot.database.createWL({
            userId: user.id,
            username: user.username,
            robloxPseudo,
            age,
            availability,
            appointmentTime
        });

        logger.success(`Demande WL cr√©√©e: ${wlId}`, { 
            wlId, 
            userId: user.id, 
            username: user.username,
            robloxPseudo,
            age 
        });

        // Embed de confirmation
        const confirmEmbed = new EmbedBuilder()
            .setTitle('‚úÖ Demande enregistr√©e')
            .setDescription(`Votre demande de whitelist a √©t√© enregistr√©e avec l'ID: \`${wlId}\``)
            .addFields(
                { name: 'üìÖ Disponibilit√©s', value: availability, inline: false },
                { name: 'üéÆ Pseudo Roblox', value: robloxPseudo, inline: true },
                { name: 'üéÇ √Çge', value: age ? age.toString() : 'Non renseign√©', inline: true }
            )
            .setColor(config.COLORS.SUCCESS)
            .setFooter({ text: 'Vous serez contact√© pour votre entretien' });

        await dmChannel.send({ embeds: [confirmEmbed] });

        // Envoyer dans le salon staff
        const guild = interaction.guild;
        const staffChannel = guild.channels.cache.get(config.WL_LOGS_CHANNEL);
        
        if (staffChannel) {
            logger.debug(`Envoi embed staff dans salon ${staffChannel.name}`, { channelId: staffChannel.id });
            
            const wlData = await bot.database.getWL(wlId);
            const staffEmbed = createWLReportEmbed(wlData, null);
            await staffChannel.send(staffEmbed);
            
            logger.success('Embed staff envoy√©', { channelId: staffChannel.id, wlId });
        } else {
            logger.error(`Salon WL_LOGS_CHANNEL introuvable`, { 
                configChannelId: config.WL_LOGS_CHANNEL,
                availableChannels: guild.channels.cache.map(c => ({ id: c.id, name: c.name }))
            }, { critical: true });
        }

        await interaction.editReply({ content: '‚úÖ Votre demande a √©t√© envoy√©e en MP!' });

    } catch (error) {
        logger.error('Erreur dans handleWLRequest', error, { 
            critical: true, 
            memory: true,
            userId: user.id,
            username: user.username
        });
        await interaction.editReply({ content: '‚ùå Une erreur est survenue. Veuillez r√©essayer.' });
    }
}

async function handleWLReady(interaction, bot) {
    await interaction.deferUpdate();
    const member = interaction.member;
    
    logger.info(`WL Ready demand√© par ${member.user.username}`, { userId: member.user.id });
    
    // V√©rifier permissions - utiliser nom de r√¥le au lieu d'ID pour compatibilit√©
    const hasStaffRole = config.STAFF_ROLE_ID ? 
        member.roles.cache.has(config.STAFF_ROLE_ID) :
        member.roles.cache.some(role => role.name === (config.STAFF_ROLE || 'Staff'));
    
    if (!hasStaffRole) {
        logger.warn('Acc√®s refus√© WL Ready - pas staff', { userId: member.user.id });
        await interaction.followUp({ content: '‚ùå Seul le staff peut utiliser cette fonction.', ephemeral: true });
        return;
    }

    // Trouver une vocal WL libre
    let availableChannel = null;
    for (const channelId of config.WL_VOCAL_CHANNELS) {
        const channel = interaction.guild.channels.cache.get(channelId);
        if (channel && channel.members.size === 0) {
            availableChannel = channel;
            break;
        }
    }

    if (!availableChannel) {
        logger.warn('Aucune vocal WL libre', { 
            vocalChannels: config.WL_VOCAL_CHANNELS,
            occupancy: config.WL_VOCAL_CHANNELS.map(id => {
                const ch = interaction.guild.channels.cache.get(id);
                return { id, name: ch?.name, members: ch?.members.size || 0 };
            })
        });
        await interaction.followUp({ content: '‚ùå Toutes les salles de whitelist sont occup√©es.', ephemeral: true });
        return;
    }

    // D√©placer les membres de la salle d'attente
    const waitingRoom = interaction.guild.channels.cache.get(config.WL_WAITING_ROOM);
    if (waitingRoom && waitingRoom.members.size > 0) {
        const memberToMove = waitingRoom.members.first();
        
        logger.info(`D√©placement ${memberToMove.user.username} vers ${availableChannel.name}`, {
            fromChannel: waitingRoom.name,
            toChannel: availableChannel.name,
            movedUserId: memberToMove.user.id,
            staffId: member.user.id
        });
        
        await memberToMove.voice.setChannel(availableChannel);
        
        const embed = new EmbedBuilder()
            .setTitle('üéôÔ∏è Whitelist en cours')
            .setDescription(`${memberToMove.user.username} a √©t√© d√©plac√© vers ${availableChannel.name}`)
            .setColor(config.COLORS.SUCCESS)
            .setTimestamp();

        await interaction.followUp({ embeds: [embed] });
    } else {
        logger.warn('Aucun joueur en salle d\'attente', { 
            waitingRoomId: config.WL_WAITING_ROOM,
            waitingRoomExists: !!waitingRoom,
            waitingRoomMembers: waitingRoom?.members.size || 0
        });
        await interaction.followUp({ content: '‚ùå Aucun joueur en attente.', ephemeral: true });
    }
}

async function handleWLAccept(interaction, bot) {
    const wlId = interaction.customId.replace('wl_accept_', '');
    await interaction.deferUpdate();

    logger.info(`WL accept√©e: ${wlId}`, { wlId, staffId: interaction.user.id, staff: interaction.user.username });

    await bot.database.updateWLStatus(wlId, 'accepted', interaction.user.id, interaction.user.username);

    const embed = EmbedBuilder.from(interaction.message.embeds[0])
        .setColor(config.COLORS.SUCCESS);
        
    const fields = embed.data.fields;
    const statusFieldIndex = fields.findIndex(field => field.name === 'üìù Statut');
    if (statusFieldIndex !== -1) {
        fields[statusFieldIndex].value = '‚úÖ Accept√©';
    }

    await interaction.editReply({ embeds: [embed], components: [] });
    
    logger.success(`WL ${wlId} accept√©e avec succ√®s`, { wlId, staffId: interaction.user.id });
}

async function handleWLRefuse(interaction, bot) {
    const wlId = interaction.customId.replace('wl_refuse_', '');
    await interaction.deferUpdate();

    logger.info(`WL refus√©e: ${wlId}`, { wlId, staffId: interaction.user.id, staff: interaction.user.username });

    await bot.database.updateWLStatus(wlId, 'refused', interaction.user.id, interaction.user.username);

    const embed = EmbedBuilder.from(interaction.message.embeds[0])
        .setColor(config.COLORS.ERROR);
        
    const fields = embed.data.fields;
    const statusFieldIndex = fields.findIndex(field => field.name === 'üìù Statut');
    if (statusFieldIndex !== -1) {
        fields[statusFieldIndex].value = '‚ùå Refus√©';
    }

    await interaction.editReply({ embeds: [embed], components: [] });
    
    logger.success(`WL ${wlId} refus√©e avec succ√®s`, { wlId, staffId: interaction.user.id });
}

async function handleWLNotes(interaction, bot) {
    const wlId = interaction.customId.replace('wl_notes_', '');
    
    logger.info(`Ajout de notes WL: ${wlId}`, { wlId, staffId: interaction.user.id });
    
    const modal = new ModalBuilder()
        .setCustomId(`wl_notes_modal_${wlId}`)
        .setTitle('Ajouter des remarques');

    const notesInput = new TextInputBuilder()
        .setCustomId('notes')
        .setLabel('Remarques')
        .setStyle(TextInputStyle.Paragraph)
        .setPlaceholder('Ajoutez vos remarques ici...')
        .setRequired(false)
        .setMaxLength(1000);

    modal.addComponents(new ActionRowBuilder().addComponents(notesInput));
    await interaction.showModal(modal);
}

// ==================== FICHE RP HANDLERS ====================

async function handleFicheAccept(interaction, bot) {
    const ficheId = interaction.customId.replace('fiche_accept_', '');
    await interaction.deferUpdate();

    logger.info(`Fiche accept√©e: ${ficheId}`, { ficheId, staffId: interaction.user.id, staff: interaction.user.username });

    // V√©rifier permissions staff
    const hasStaffRole = config.STAFF_ROLE_ID ? 
        interaction.member.roles.cache.has(config.STAFF_ROLE_ID) :
        interaction.member.roles.cache.some(role => role.name === (config.STAFF_ROLE || 'Staff'));
    
    if (!hasStaffRole) {
        logger.warn('Acc√®s refus√© fiche accept - pas staff', { userId: interaction.user.id, ficheId });
        await interaction.followUp({ content: '‚ùå Seul le staff peut valider les fiches.', ephemeral: true });
        return;
    }

    await bot.database.updateFicheRPStatus(ficheId, 'accepted', interaction.user.id, interaction.user.username);

    const embed = EmbedBuilder.from(interaction.message.embeds[0])
        .setColor(config.COLORS.SUCCESS)
        .setFooter({ text: `‚úÖ Accept√©e par ${interaction.user.username} le ${new Date().toLocaleDateString('fr-FR')}` });

    await interaction.editReply({ embeds: [embed], components: [] });

    // Archiver dans le salon valid√©
    const guild = interaction.guild;
    const validatedChannel = guild.channels.cache.get(config.FICHES_VALIDATED_CHANNEL);
    if (validatedChannel) {
        await validatedChannel.send({ embeds: [embed] });
        logger.success(`Fiche ${ficheId} archiv√©e dans ${validatedChannel.name}`, { ficheId, channelId: validatedChannel.id });
    } else {
        logger.error(`Salon FICHES_VALIDATED_CHANNEL introuvable`, { 
            configChannelId: config.FICHES_VALIDATED_CHANNEL,
            ficheId 
        });
    }

    // Notifier l'utilisateur en MP
    try {
        const ficheData = await bot.database.getFicheRP(ficheId);
        const user = await interaction.client.users.fetch(ficheData.user_id);
        
        const notifyEmbed = new EmbedBuilder()
            .setTitle('‚úÖ Fiche RP Accept√©e!')
            .setDescription(`Votre fiche RP **${ficheData.prenom_nom}** (\`${ficheId}\`) a √©t√© accept√©e par le staff!`)
            .setColor(config.COLORS.SUCCESS)
            .setTimestamp();

        await user.send({ embeds: [notifyEmbed] });
        logger.success(`Notification MP envoy√©e pour fiche ${ficheId}`, { ficheId, userId: user.id });
    } catch (error) {
        logger.warn(`Impossible de notifier l'utilisateur pour fiche ${ficheId}`, error, { ficheId });
    }
}

async function handleFicheRefuse(interaction, bot) {
    const ficheId = interaction.customId.replace('fiche_refuse_', '');
    
    logger.info(`Fiche refus√©e: ${ficheId}`, { ficheId, staffId: interaction.user.id });
    
    // V√©rifier permissions staff
    const hasStaffRole = config.STAFF_ROLE_ID ? 
        interaction.member.roles.cache.has(config.STAFF_ROLE_ID) :
        interaction.member.roles.cache.some(role => role.name === (config.STAFF_ROLE || 'Staff'));
    
    if (!hasStaffRole) {
        logger.warn('Acc√®s refus√© fiche refuse - pas staff', { userId: interaction.user.id, ficheId });
        await interaction.reply({ content: '‚ùå Seul le staff peut refuser les fiches.', ephemeral: true });
        return;
    }
    
    const modal = new ModalBuilder()
        .setCustomId(`fiche_refuse_modal_${ficheId}`)
        .setTitle('Motif du refus');

    const reasonInput = new TextInputBuilder()
        .setCustomId('reason')
        .setLabel('Raison du refus (obligatoire)')
        .setStyle(TextInputStyle.Paragraph)
        .setPlaceholder('Expliquez pourquoi la fiche est refus√©e...')
        .setRequired(true)
        .setMaxLength(1000);

    modal.addComponents(new ActionRowBuilder().addComponents(reasonInput));
    await interaction.showModal(modal);
}

async function handleFicheEdit(interaction, bot) {
    const ficheId = interaction.customId.replace('fiche_edit_', '');
    await interaction.deferUpdate();

    logger.info(`Fiche correction demand√©e: ${ficheId}`, { ficheId, staffId: interaction.user.id });

    // V√©rifier permissions staff
    const hasStaffRole = config.STAFF_ROLE_ID ? 
        interaction.member.roles.cache.has(config.STAFF_ROLE_ID) :
        interaction.member.roles.cache.some(role => role.name === (config.STAFF_ROLE || 'Staff'));
    
    if (!hasStaffRole) {
        logger.warn('Acc√®s refus√© fiche edit - pas staff', { userId: interaction.user.id, ficheId });
        await interaction.followUp({ content: '‚ùå Seul le staff peut demander des corrections.', ephemeral: true });
        return;
    }

    await interaction.followUp({ 
        content: 'üîÑ Fonction de correction en cours de d√©veloppement.\nPour l\'instant, utilisez le bouton "Refuser" avec des instructions de correction.', 
        ephemeral: true 
    });
}

// Fonction pour cr√©er l'embed WL (fallback si l'import √©choue)
function createWLReportEmbed(wlData, staff) {
    const embed = new EmbedBuilder()
        .setTitle(`üìã Compte-rendu Whitelist - ${wlData.id}`)
        .addFields(
            { name: 'üë§ Joueur', value: wlData.username, inline: true },
            { name: 'üë®‚Äçüíº Staff', value: staff ? staff.username : 'Aucun', inline: true },
            { name: 'üéÆ Pseudo Roblox', value: wlData.roblox_pseudo || 'Non renseign√©', inline: true },
            { name: 'üìÖ Disponibilit√©s', value: wlData.availability || 'Non renseign√©es', inline: false },
            { name: 'üéÇ √Çge', value: wlData.age ? wlData.age.toString() : 'Non renseign√©', inline: true },
            { name: 'üìù Statut', value: '‚è≥ En attente', inline: true }
        )
        .setColor(config.COLORS.PENDING)
        .setTimestamp();

    return { embeds: [embed], components: [] };
}

module.exports = { handle };